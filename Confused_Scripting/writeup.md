# CTF Web-Challenge | Confused Scripting Writeup: Easy Level

## Challenge Overview

In this challenge, the user is provided with a Python script that dynamically generates an encrypted flag and obfuscates the encryption function. The goal is to reverse-engineer the obfuscated function and decrypt the intercepted output to retrieve the flag.

### Key Details from the Script

1. **Dynamic Flag Generation**:
   - The flag is generated by combining a `CHALLENGEKEY` and a `TEAMKEY` (provided via environment variables).
   - The combined string is hashed using SHA-256 to create the flag in the format `FF{<hash>}`.

2. **Encryption Process**:
   - The flag is encrypted using AES encryption in CBC mode.
   - A random 16-byte initialization vector (IV) is generated for each encryption.
   - The encryption key is a randomly generated 16-byte value.

3. **Obfuscation**:
   - The script dynamically generates an obfuscated encryption function by hashing random words to create variable and function names.
   - The obfuscated function is written to a file (`obfuscated.py`) along with the intercepted encrypted flag.

### Steps to Solve

1. **Analyze the Script**:
   - Understand the dynamic flag generation and encryption process.
   - Identify the hardcoded encryption key and IV in the obfuscated function.

2. **Decrypt the Intercepted Output**:
   - Use the AES decryption process with the extracted key and IV to decrypt the intercepted output.

3. **Example Decryption Function**:
   - The following function can be used to decrypt the intercepted output:
     ```py
     def decrypt(encrypted_text, key):
         from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
         from cryptography.hazmat.primitives import padding
         from cryptography.hazmat.backends import default_backend
         import base64

         encrypted_data = base64.b64decode(encrypted_text)
         iv = encrypted_data[:16]
         encrypted_flag = encrypted_data[16:]
         cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
         decryptor = cipher.decryptor()
         padded_flag = decryptor.update(encrypted_flag) + decryptor.finalize()
         unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
         flag = unpadder.update(padded_flag) + unpadder.finalize()
         return flag.decode()
     ```

4. **Intercepted Output**:
   - The intercepted encrypted flag is provided in the script as a hint. Use it along with the decryption function to retrieve the original flag.

## Conclusion

This challenge demonstrates how to analyze obfuscated Python code, reverse-engineer encryption processes, and decrypt data. It is a great exercise for understanding AES encryption and dynamic code generation.
