# Corrupted File

A challenge with the goal to identify and correct a corrupted file signature to retrieve a hidden flag.
**Level**: Medium

## Challenge Overview:

The user receives a file with a corrupted signature. The task is to identify the corruption, correct the file signature, and extract the contents to find the hidden flag.
---

### Dockerfile

The `Dockerfile` installs a Python 3.9 environment and adds the dependencies from requirements.txt. The dependencies include mostly things for FastAPI, which is used to present the file to the user.
```yml
FROM python:3.9

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

COPY ./app /code/app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "80"]
```

### Python script

The `main.py` includes all the code necessary for running this challenge. It consists of two parts: the flag generation and the FastAPI service. The flag is generated by combining a team key and a challenge key, hashing the result, and saving it to a file. The file is then compressed into a tar.gz archive, and the first two bytes of the archive are altered to hide the file type.

The code contains some debug information that can be used to solve the challenge if it is too hard by setting an environment variable "DEBUG" to "True".

```python
import hashlib
import os
import tarfile

from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.responses import FileResponse

if os.environ.get("TEAMKEY") is None:
    load_dotenv()

debug = os.getenv("DEBUG", "False") == "True"
print(debug)

team_key = os.getenv("TEAMKEY")
challenge_key = os.getenv("CHALLENGE")
combined_flag = challenge_key + team_key
hashed_flag = f"FF{{{hashlib.md5(combined_flag.encode()).hexdigest()}}}"
if debug:
    print(f"Team Key: {team_key}")
    print(f"Challenge Key: {challenge_key}")
    print(f"Flag: {hashed_flag}")

#create a text file with the flag
with open ("flag.txt", "w") as f:
    f.write(hashed_flag)

#compress the file to a tar.gz file
with tarfile.open("document", 'w:gz') as tar:
    tar.add("flag.txt")

#replace the first two bytes from the archive from 0x1f 0x8b to 0x00 0x00 to hide the file type
#makes it practically impossible without altering the bytes back
with open("document", 'r+b') as f:
    f.seek(0)  # Move to the beginning of the file
    f.write(b'\x00\x00')  # Write the new bytes

app = FastAPI()

@app.get("/")
def read_root():
    file_path = "document"
    #send some additional headers because firefox can't be normal
    headers = {'Content-Disposition': 'attachment; filename="document"'}
    return FileResponse(file_path, headers=headers)
```

## Technical guideline

### Installation

> [!NOTE]
> Make sure to install docker and docker-compose first

**Linux**

- [Docker Linux installation](https://docs.docker.com/engine/install/ubuntu/)

- [Docker-compose Linux installation](https://docs.docker.com/compose/install/linux/)

**Windows**

- [Docker Windows installation](https://docs.docker.com/desktop/setup/install/windows-install/)

- [Docker-compose Windows installation](https://docs.docker.com/compose/install/)

After you installed docker and docker-compose, you need to pull the repository via CLI using this command.

```
git pull https://github.com/CTF-FlagFrenzy/challenges.git
```

Then navigate to the root of the `Corrupted_File` challenge and type the following command in the CLI.

```
docker-compose up
```

You can see all running containers with `docker ps`.

**HAVE FUN**

> [!NOTE]
> If you have any problems solving this challenge, you can find a full guide [here](https://github.com/CTF-FlagFrenzy/challenges/blob/main/Corrupted_File/writeup.md)
